# SpringCache 介绍

SpringCache 是 SpringFramework 3.1 引入的新特性，提供了基于==注解==的缓存配置方法。它本质上<font color=red>不是一个具体的缓存实现方案</font>（例如EHCache），而是一个<font color=red>对缓存使用的抽象</font>。通过在已有代码中打上几个预定义的注释，就可以实现我们希望达到的缓存效果。

SpringCache 支持和第三方缓存例如EHCache集成；另外也提供了开箱即用的默认实现，可以直接拿来使用。

SpringCache 支持使用 SpEL（Spring Expression Language）来定义缓存的 key 和各种 condition，因此具备相当的灵活性，并可以支持非常复杂的语义。



# 使用样例

## 配置 CacheManager 与 Cache

由于是 SpringFramework 的内置功能，使用 SpringCache 并不需要额外引入jar包。并且只需要简单的配置，就可以启用==开箱即用的默认缓存==实现。

创建 `Configuration` 类，在其中配置 `CacheManager Bean`，并为其创建两个 cache（注意cache的名称，在下面需要缓存的方法上打注释配置时需要指定）：

```java
@Configuration
@EnableCaching(proxyTargetClass = true)
public class Configuration{
	@Bean(name="simpleCacheManager")
	public CacheManager simpleCacheManager(){
		SimpleCacheManager cacheManager = new SimpleCacheManager();
		List<Cache> caches = new ArrayList<Cache>();
		ConcurrentMapCache cache1 = new ConcurrentMapCache("mycache");
		ConcurrentMapCache cache2 = new ConcurrentMapCache("mycache2");
		caches.add(cache1);
		caches.add(cache2);
		cacheManager.setCaches(caches);
		return cacheManager;
	}
}
```

Configuration 类上的`@EnableCaching(proxyTargetClass = true)`注释表示==启动SpringCache功能==。

```java
package org.springframework.cache.annotation;

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import({CachingConfigurationSelector.class})
public @interface EnableCaching {
    boolean proxyTargetClass() default false;

    AdviceMode mode() default AdviceMode.PROXY;

    int order() default 2147483647;
}
```

其中`proxyTargetClass`表示：当需要代理的类是一个==接口==或者是一个==动态生成的代理类==时使用`JdkProxy`代理；而当要代理的类是一个==具体类==时，使用`cglib`来代理。

假如不设置该属性，则默认使用`JdkProxy`代理，而<font color=red>`JdkProxy`能够代理的类必须实现接口</font>，因此如果想要一个没实现接口的类被代理，就必须设置`proxyTargetClass = true`来使用`cglib`完成代理。

`@EnableCaching` 还有一个属性`AdviceMode mode`，取值有两个`AdviceMode.PROXY`和`AdviceMode.ASPECTJ`，意思是 Spring AOP 使用==代理模式==实现，还是使用==原生 AspectJ 模式==实现，默认是代理模式。

> - [ ] 学习 Spring AOP 代理模式

`SimpleCacheManager`与`ConcurrentMapCache`都是 SpringCache 提供的默认实现。而当我们使用 SpringBoot 时，<font color=red>由于其 `spring-boot-autoconfigure` 模块里对 SpringCache 做了默认的自动配置，因此我们甚至连 CacheManager 都不需要配置。仅仅在 Configuration 类上打上`@EnableCaching(proxyTargetClass = true)`注释便可以启动 Springcache 了</font>。

> - [ ] 学习 spring-boot-autoconfigure

## 使用注释

光是启用 SpringCache 并没有用，我们还<font color=red>需要指明在哪些类的哪些方法上需要缓存，以及需要什么样的缓存行为</font>。

SpringCache 提供了`@Cacheable、@CachePut、@CacheEvict`等注释，并支持使用SpEL（Spring Expression Language）来定义缓存的 key 和各种 condition，因此具备相当的灵活性，并可以支持非常复杂的语义。

```java
@Service
public class UserService {
	@CacheEvict(value={"mycache", "mycache2"}, allEntries = true)
	public void clearCache(){
		
	}
	
	@CachePut(value = "mycache", key = "#user.id")    
	public User save(User user) {    
	    return user;    
	}
	
	@Cacheable(value="mycache2", key = "#username.concat(#email)", condition = "#username eq 'wangd'")
	public User findByUsernameAndEmail(String username, String email){
		Random random = new Random();
        User user = new User(System.currentTimeMillis() + random.nextInt(10000), username, email);
        return user;
	}

}
```



## 自定义 CacheManager 和 Cache

SpringCache 本质上是一个==对缓存使用的抽象==，将存储的具体实现方案，从缓存执行动作及流程中提取出来。

缓存流程中面向的两个抽象接口是`CacheManager、Cache`。其中 Cache 提供了缓存操作的读取、写入、移除等方法，<font color=red>本着面向抽象编程的原则，内部将缓存对象统一封装成`ValueWrapper`</font>。

### Cache 接口

Cache 接口代码如下：

```java
package org.springframework.cache;

import java.util.concurrent.Callable;
import org.springframework.lang.Nullable;

/**
 * Interface that defines common cache operations.
 */
public interface Cache {

	/**
	 * Return the cache name.
	 * cacheName，缓存的名字，默认实现中一般是CacheManager创建Cache的bean时传入cacheName
	 */
	String getName();

	/**
	 * Return the underlying native cache provider.
	 * 得到底层使用的缓存，如Ehcache
	 */
	Object getNativeCache();

	/**
	 * Return the value to which this cache maps the specified key.
	 * 通过key获取缓存值，返回的是ValueWrapper，
	 * 为了兼容存储空值的情况，将返回值包装了一层，通过get方法获取实际值
	 */
	@Nullable
	ValueWrapper get(Object key);

	/**
	 * Return the value to which this cache maps the specified key,
	 * generically specifying a type that return value will be cast to.
	 * 通过key获取缓存值，返回的是实际值，即方法的返回值类型
	 */
	@Nullable
	<T> T get(Object key, @Nullable Class<T> type);

	/**
	 * 通过key获取缓存值，可以使用valueLoader.call()来调使用@Cacheable注解的方法。
	 * 当@Cacheable注解的sync属性配置为true时使用此方法。
	 * 因此方法内需要保证回源到数据库的同步性。避免在缓存失效时大量请求回源到数据库。
	 */
	@Nullable
	<T> T get(Object key, Callable<T> valueLoader);

	/**
	 * Associate the specified value with the specified key in this cache.
	 * 将@Cacheable注解方法返回的数据放入缓存中
	 */
	void put(Object key, @Nullable Object value);

	/**
	 * 当缓存中不存在key时才放入缓存。返回值是当key存在时原有的数据
	 */
	@Nullable
	default ValueWrapper putIfAbsent(Object key, @Nullable Object value) {
		ValueWrapper existingValue = get(key);
		if (existingValue == null) {
			put(key, value);
		}
		return existingValue;
	}

	/**
	 * Evict the mapping for this key from this cache if it is present.
	 * 删除缓存
	 */
	void evict(Object key);

	/**
	 * Evict the mapping for this key from this cache if it is present
	 */
	default boolean evictIfPresent(Object key) {
		evict(key);
		return false;
	}

	/**
	 * 清空缓存
	 */
	void clear();

	/**
	 * Invalidate the cache through removing all mappings, expecting all
	 * entries to be immediately invisible for subsequent lookups.
	 */
	default boolean invalidate() {
		clear();
		return false;
	}


	/**
	 * A (wrapper) object representing a cache value.
	 * 缓存返回值的包装
	 */
	@FunctionalInterface
	interface ValueWrapper {
		/**
		 * Return the actual value in the cache.
		 */
		@Nullable
		Object get();
	}
}
```

### CacheManager 接口

由于在应用中可能==定义多个Cache==，因此提供了 CacheManager 抽象，<font color=red>用于缓存的管理</font>，主要提供 Cache 实现 bean 的创建，每个应用里可以通过 cacheName 来对 Cache 进行隔离，每个 cacheName 对应一个 Cache 实现。接口代码如下：

```java
package org.springframework.cache;

import java.util.Collection;
import org.springframework.lang.Nullable;

public interface CacheManager {

	/**
	 * 通过cacheName创建Cache的实现bean，具体实现中需要存储已创建的Cache实现bean，避免重复创建，
	 * 也避免内存缓存对象（如Caffeine）重新创建后原来缓存内容丢失的情况
	 */
	@Nullable
	Cache getCache(String name);

	/**
	 * 返回所有的cacheName
	 */
	Collection<String> getCacheNames();

}
```

### 自定义缓存实现

任何实现了这两个接口的缓存方案，都可以直接配置进 SpringCache 使用。其自带的`SimpleCacheManager、ConcurrentMapCache`是如此；使用 ehcache 作为存储实现的`EhCacheCacheManager、EhCacheCache`也是如此。我们可以自己实现 CacheManager 与 Cache，并将其集成进来。

为了方便展示，我们自定义缓存实现方案只实现最简单的功能，cache 内部使用 ConcurrentHashMap 做为存储方案，使用默认实现 SimpleValueWrapper。

MyCache 代码如下：

```java
public class MyCache implements Cache {
	final static Logger logger = LoggerFactory.getLogger(MyCache.class);
	
	String name;
	Map<Object, Object> store = new ConcurrentHashMap<Object, Object>();
	
    public MyCache() { 
    } 
	  
    public MyCache(String name) { 
        this.name = name; 
    } 
    
	@Override
	public String getName() {
		return this.name;
	}
	public void setName(String name){
		this.name = name;
	}
 
	@Override
	public Object getNativeCache() {
		return store;
	}
 
	@Override
	public ValueWrapper get(Object key) {
		ValueWrapper result = null; 
	    Object thevalue = store.get(key); 
	    if(thevalue!=null) { 
	    	logger.info("["+name+"]got cache, key:"+key);
	      result = new SimpleValueWrapper(thevalue); 
	    }else{
	    	logger.info("["+name+"]missing cache, key:"+key);
	    }
	    return result;
	}
 
	@SuppressWarnings("unchecked")
	@Override
	public <T> T get(Object key, Class<T> type) {
		ValueWrapper vw = get(key);
		if(vw==null){
			return null;
		}
		return (T)vw.get();
	}
 
	@SuppressWarnings("unchecked")
	@Override
	public <T> T get(Object key, Callable<T> valueLoader) {
		ValueWrapper vw = get(key);
		if(vw==null){
			return null;
		}
		return (T)vw.get();
	}
 
	@Override
	public void put(Object key, Object value) {
		store.put(key, value);
	}
 
	@Override
	public ValueWrapper putIfAbsent(Object key, Object value) {
		Object existing = this.store.putIfAbsent(key, value);
		return (existing != null ? new SimpleValueWrapper(existing) : null);
	}
 
	@Override
	public void evict(Object key) {
		store.remove(key);
	}
 
	@Override
	public void clear() {
		store.clear();
	}
}
```

MyCacheManager：

```java
public class MyCacheManager extends AbstractCacheManager {
	private Collection<? extends MyCache> caches; 
	  
	  /** 
	  * Specify the collection of Cache instances to use for this CacheManager. 
	  */ 
	  public void setCaches(Collection<? extends MyCache> caches) { 
	    this.caches = caches; 
	  } 
	 
	  @Override 
	  protected Collection<? extends MyCache> loadCaches() { 
	    return this.caches; 
	  } 
}
```

接下来在 Configuration 中配置我们自己定制的 Cache 实现方案：

```java
@Bean(name="myCacheManager")
public CacheManager myCacheManager(){
    MyCacheManager myCacheManager = new MyCacheManager();
    List<MyCache> caches = new ArrayList<MyCache>();
    MyCache mycache = new MyCache("mycache");
    MyCache mycache2 = new MyCache("mycache2");
    caches.add(mycache);
    caches.add(mycache2);
    myCacheManager.setCaches(caches);
    return myCacheManager;
}
```



# SpringCache 实现原理

SpringCache 使用 Spring AOP 来实现，当我们在 Configuration 类打上 @EnableCaching 注释时，该标注通过 `ImportSelector` 机制启动 `AbstractAdvisorAutoProxyCreator` 的一个实例，该实例本身是一个 Ordered BeanPostProcessor，<font color=red>BeanPostProcessor 的作用是在 bean 创建、初始化的前后对其进行一些额外的操作（包括创建代理）</font>。因此可以认为当在 Configuration 类打上 @EnableCaching 注释时，做的第一件事情就是启用 Spring AOP 机制。

SpringCache 使用 Spring AOP 面向切面编程的机制来实现，当我们在 Configuration 类打上 @EnableCaching 注释时，除了启动 Spring AOP 机制外，引入的另一个类 `ProxyCachingConfiguration` 就是 SpringCache 具体实现相关 bean 的配置类。

其代码如下：

```java
package org.springframework.cache.annotation;

@Configuration
@Role(2)
public class ProxyCachingConfiguration extends AbstractCachingConfiguration {
    public ProxyCachingConfiguration() {
    }

    @Bean(
        name = {"org.springframework.cache.config.internalCacheAdvisor"}
    )
    @Role(2)
    public BeanFactoryCacheOperationSourceAdvisor cacheAdvisor() {
        BeanFactoryCacheOperationSourceAdvisor advisor = new BeanFactoryCacheOperationSourceAdvisor();
        advisor.setCacheOperationSource(this.cacheOperationSource());
        advisor.setAdvice(this.cacheInterceptor());
        if (this.enableCaching != null) {
            advisor.setOrder((Integer)this.enableCaching.getNumber("order"));
        }

        return advisor;
    }

    @Bean
    @Role(2)
    public CacheOperationSource cacheOperationSource() {
        // 获取定义在类和方法上的 SpringCache 相关的注解，并将其转换为对应的 CacheOperation 属性
        return new AnnotationCacheOperationSource();
    }

    @Bean
    @Role(2)
    public CacheInterceptor cacheInterceptor() {
        CacheInterceptor interceptor = new CacheInterceptor();
        interceptor.configure(this.errorHandler, this.keyGenerator, this.cacheResolver, this.cacheManager);
        interceptor.setCacheOperationSource(this.cacheOperationSource());
        return interceptor;
    }
}
```



可以看到在其中配置了三个bean：BeanFactoryCacheOperationSourceAdvisor、AnnotationCacheOperationSource、CacheInterceptor。

- `AnnotationCacheOperationSource`的主要作用是，<font color=red>获取定义在类和方法上的 SpringCache 相关的注解，并将其转换为对应的 CacheOperation 属性</font>。
- `BeanFactoryCacheOperationSourceAdvisor`是一个`PointcutAdvisor`，是 SpringCache 使用 Spring AOP 机制的关键所在，该 advisor 会织入到需要执行缓存操作的 bean 的增强代理中，形成一个切面。并在方法调用时，在该切面上执行拦截器 CacheInterceptor 的业务逻辑。
- `CacheInterceptor`是一个拦截器，当方法调用时碰到了 BeanFactoryCacheOperationSourceAdvisor 定义的切面，就会执行 CacheInterceptor 的业务逻辑，该业务逻辑就是==缓存的核心业务逻辑==。



## AnnotationCacheOperationSource

其继承路径是：

`AnnotationCacheOperationSource` $\rightarrow$ `AbstractFallbackCacheOperationSource` $\rightarrow$ `CacheOperationSource`

其中 `CacheOperationSource` 接口定义了一个方法：

```java
package org.springframework.cache.interceptor;

public interface CacheOperationSource {
    default boolean isCandidateClass(Class<?> targetClass) {
        return true;
    }

    @Nullable
    Collection<CacheOperation> getCacheOperations(Method var1, @Nullable Class<?> var2);
}
```

该方法用于根据<font color=red>指定类上的指定方法上打的 SpringCache 注释来得到对应的 CacheOperation 集合</font>。

### AbstractFallbackCacheOperationSource

`AbstractFallbackCacheOperationSource`是 CacheOperationSource 的抽象实现类，采用==模板模式==将获取某类的某方法上的 CacheOperation 的业务流程固化。该固化的流程可<font color=red>将方法上的属性缓存，并实现了一个获取 CacheOperation 的 fallback 策略</font>，执行的顺序为：

1、目标方法；2、目标类；3、声明方法；4、声明类/接口。

当方法被调用过一次之后，其上的属性就会被缓存。

它提供了两个抽象模板方法，供具体的子类来实现：

```java
@Nullable
public Collection<CacheOperation> getCacheOperations(Method method, @Nullable Class<?> targetClass) {
    if (method.getDeclaringClass() == Object.class) {
        return null;
    } else {
        Object cacheKey = this.getCacheKey(method, targetClass);
        Collection<CacheOperation> cached = (Collection)this.attributeCache.get(cacheKey);
        if (cached != null) {
            return cached != NULL_CACHING_ATTRIBUTE ? cached : null;
        } else {
            Collection<CacheOperation> cacheOps = this.computeCacheOperations(method, targetClass);
            if (cacheOps != null) {
                if (this.logger.isTraceEnabled()) {
                    this.logger.trace("Adding cacheable method '" + method.getName() + "' with attribute: " + cacheOps);
                }

                this.attributeCache.put(cacheKey, cacheOps);
            } else {
                this.attributeCache.put(cacheKey, NULL_CACHING_ATTRIBUTE);
            }

            return cacheOps;
        }
    }
}

@Nullable
protected abstract Collection<CacheOperation> findCacheOperations(Class<?> var1);

@Nullable
protected abstract Collection<CacheOperation> findCacheOperations(Method var1);
```

### AnnotationCacheOperationSource

AnnotationCacheOperationSource 内部持有一个`Set<CacheAnnotaionParser>`的集合，默认包含`SpringCacheAnnotationParser`，并使用 SpringCacheAnnotationParser 来实现 AbstractFallbackCacheOperationSource 定义的两个抽象方法。

`class AnnotationCacheOperationSource`：

```java
private final Set<CacheAnnotationParser> annotationParsers;

public AnnotationCacheOperationSource(Set<CacheAnnotationParser> annotationParsers) {
    this.publicMethodsOnly = true;
    Assert.notEmpty(annotationParsers, "At least one CacheAnnotationParser needs to be specified");
    this.annotationParsers = annotationParsers;
}

@Nullable
protected Collection<CacheOperation> findCacheOperations(Class<?> clazz) {
    return this.determineCacheOperations((parser) -> {
        return parser.parseCacheAnnotations(clazz);
    });
}

@Nullable
protected Collection<CacheOperation> findCacheOperations(Method method) {
    return this.determineCacheOperations((parser) -> {
        return parser.parseCacheAnnotations(method);
    });
}

@Nullable
protected Collection<CacheOperation> determineCacheOperations(AnnotationCacheOperationSource.CacheOperationProvider provider) {
    Collection<CacheOperation> ops = null;
    Iterator var3 = this.annotationParsers.iterator();

    while(var3.hasNext()) {
        CacheAnnotationParser parser = (CacheAnnotationParser)var3.next();
        Collection<CacheOperation> annOps = provider.getCacheOperations(parser);
        if (annOps != null) {
            if (ops == null) {
                ops = annOps;
            } else {
                Collection<CacheOperation> combined = new ArrayList(((Collection)ops).size() + annOps.size());
                combined.addAll((Collection)ops);
                combined.addAll(annOps);
                ops = combined;
            }
        }
    }

    return (Collection)ops;
}

@FunctionalInterface
protected interface CacheOperationProvider {
    @Nullable
    Collection<CacheOperation> getCacheOperations(CacheAnnotationParser var1);
}
```

具体实现使用回调模式，用`Set<CacheAnnotaionParser>`中的每一个 CacheAnnotaionParser 去解析一个方法或类，然后将得到的`List<CacheOperation>`合并，最终返回。

### CacheAnnotaionParser

该接口定义了两个方法：

```java
public interface CacheAnnotationParser {
    default boolean isCandidateClass(Class<?> targetClass) {
        return true;
    }
	// 解析类上的标注，并相应创建 CacheOperation
    @Nullable
    Collection<CacheOperation> parseCacheAnnotations(Class<?> var1);
	// 解析方法上的标注，并相应创建 CacheOperation
    @Nullable
    Collection<CacheOperation> parseCacheAnnotations(Method var1);
}
```

其默认实现类为`SpringCacheAnnotationParser`，在其内部对 SpringCache 的几个注解 @Cacheable、@CachePut、@CacheEvict、@Caching 进行了解析，并相应的创建 CacheableOperation、CacheEvictOperation、CachePutOperation。

### SpringCacheAnnotationParser

```java
@Nullable
private Collection<CacheOperation> parseCacheAnnotations(SpringCacheAnnotationParser.DefaultCacheConfig cachingConfig, AnnotatedElement ae, boolean localOnly) {
    Collection<? extends Annotation> anns = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, CACHE_OPERATION_ANNOTATIONS) : AnnotatedElementUtils.findAllMergedAnnotations(ae, CACHE_OPERATION_ANNOTATIONS);
    if (anns.isEmpty()) {
        return null;
    } else {
        Collection<CacheOperation> ops = new ArrayList(1);
        
        anns.stream().filter((ann) -> {
            return ann instanceof Cacheable;
        }).forEach((ann) -> {
            ops.add(this.parseCacheableAnnotation(ae, cachingConfig, (Cacheable)ann));
        });
        
        anns.stream().filter((ann) -> {
            return ann instanceof CacheEvict;
        }).forEach((ann) -> {
            ops.add(this.parseEvictAnnotation(ae, cachingConfig, (CacheEvict)ann));
        });
        
        anns.stream().filter((ann) -> {
            return ann instanceof CachePut;
        }).forEach((ann) -> {
            ops.add(this.parsePutAnnotation(ae, cachingConfig, (CachePut)ann));
        });
        
        anns.stream().filter((ann) -> {
            return ann instanceof Caching;
        }).forEach((ann) -> {
            this.parseCachingAnnotation(ae, cachingConfig, (Caching)ann, ops);
        });
        
        return ops;
    }
}
```

参数中 AnnotatedElement 是 Class 和 Method 的父类，代表了一个可被注释的元素，该参数可以是一个 Class 也可以是一个 Method。



总结：

- 首先查找该类、方法上的 Cacheable 注解并进行合并。

- 针对合并后的每个 Cacheable 创建对应的 CacheableOperation；然后同样逻辑执行 CacheEvict 和 CachePut。
- 最后处理Caching，Caching 表示的是若干组 Cache 标注的集合，将其解析成一组 CacheOperation 并添加到`Collection<CacheOperation> ops`中。



## CacheInterceptor

CacheInterceptor 继承了 `CacheAspectSupport` 并实现了 `MethodInterceptor` 接口，因此它本质上是一个 ==Advice==，也就是可在切面上执行的==增强逻辑==。

CacheInterceptor 切面的拦截方法代码如下：

```java
package org.springframework.cache.interceptor;

public class CacheInterceptor extends CacheAspectSupport implements MethodInterceptor, Serializable {
    public CacheInterceptor() {
    }

    @Nullable
    public Object invoke(MethodInvocation invocation) throws Throwable {
        Method method = invocation.getMethod();
        CacheOperationInvoker aopAllianceInvoker = () -> {
            try {
                return invocation.proceed();
            } catch (Throwable var2) {
                throw new ThrowableWrapper(var2);
            }
        };

        try {
            return this.execute(aopAllianceInvoker, invocation.getThis(), method, invocation.getArguments());
        } catch (ThrowableWrapper var5) {
            throw var5.getOriginal();
        }
    }
}
```

### CacheAspectSupport

这个增强逻辑的核心功能是在 `CacheAspectSupport` 中实现的，

首先调用`AnnotationCacheOperationSource.getCacheOperations(method, targetClass)`方法得到被调用方法的`Collection<CacheOperation>`；

然后将这些 CacheOperation 以及被调用方法、调用参数、目标类、相应的 Cache 信息统统封装到 CacheOperation 上下文里，随后调用真正的核心方法。

```java
@Nullable
protected Object execute(CacheOperationInvoker invoker, Object target, Method method, Object[] args) {
    if (this.initialized) {
        Class<?> targetClass = this.getTargetClass(target);
        CacheOperationSource cacheOperationSource = this.getCacheOperationSource();
        if (cacheOperationSource != null) {
            // 得到被调用方法的Collection<CacheOperation>
            Collection<CacheOperation> operations = cacheOperationSource.getCacheOperations(method, targetClass);
            if (!CollectionUtils.isEmpty(operations)) {
                // 将这些 CacheOperation 以及被调用方法、调用参数、目标类、相应的 Cache 信息统统封装到 CacheOperation 上下文里
                return this.execute(invoker, method, new CacheAspectSupport.CacheOperationContexts(operations, method, args, target, targetClass));
            }
        }
    }

    return invoker.invoke();
}

// 该方法封装了SpringCache核心的处理逻辑，也就是使用 Cache 配合来完成用户的方法调用，并返回结果
@Nullable
private Object execute(CacheOperationInvoker invoker, Method method, CacheAspectSupport.CacheOperationContexts contexts) {
    if (contexts.isSynchronized()) {
        CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)contexts.get(CacheableOperation.class).iterator().next();
        if (!this.isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) {
            return this.invokeOperation(invoker);
        }

        Object key = this.generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT);
        Cache cache = (Cache)context.getCaches().iterator().next();

        try {
            return this.wrapCacheValue(method, this.handleSynchronizedGet(invoker, key, cache));
        } catch (ValueRetrievalException var10) {
            ReflectionUtils.rethrowRuntimeException(var10.getCause());
        }
    }

    this.processCacheEvicts(contexts.get(CacheEvictOperation.class), true, CacheOperationExpressionEvaluator.NO_RESULT);
    ValueWrapper cacheHit = this.findCachedItem(contexts.get(CacheableOperation.class));
    List<CacheAspectSupport.CachePutRequest> cachePutRequests = new LinkedList();
    if (cacheHit == null) {
        this.collectPutRequests(contexts.get(CacheableOperation.class), CacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests);
    }

    Object returnValue;
    Object cacheValue;
    if (cacheHit != null && !this.hasCachePut(contexts)) {
        cacheValue = cacheHit.get();
        returnValue = this.wrapCacheValue(method, cacheValue);
    } else {
        returnValue = this.invokeOperation(invoker);
        cacheValue = this.unwrapReturnValue(returnValue);
    }

    this.collectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests);
    Iterator var8 = cachePutRequests.iterator();

    while(var8.hasNext()) {
        CacheAspectSupport.CachePutRequest cachePutRequest = (CacheAspectSupport.CachePutRequest)var8.next();
        cachePutRequest.apply(cacheValue);
    }

    this.processCacheEvicts(contexts.get(CacheEvictOperation.class), false, cacheValue);
    return returnValue;
}
```





## BeanFactoryCacheOperationSourceAdvisor





# 参考资料

[SpringCache实现原理及核心业务逻辑（一）_不动明王1984的博客-CSDN博客_springcache](https://blog.csdn.net/m0_37962779/article/details/78671468)

[(43条消息) Spring Cache抽象详解_不动明王1984的博客-CSDN博客](https://blog.csdn.net/m0_37962779/article/details/78464165)



# 内容

- advice：增强

- 切点：在 Spring 中, 所有的方法都可以认为是 joinpoint，但是我们并不希望在所有的方法上都添加 Advice，而 pointcut 的作用就是提供一组规则（使用 AspectJ pointcut expression language 来描述）来匹配joinpoint，给满足规则的 joinpoint 添加 Advice。

- 目标对象（Target）：织入 advice 的目标对象，目标对象也被称为 `advised object`。因为 Spring AOP 使用运行时代理的方式来实现 aspect，因此 adviced object 总是一个代理对象（proxied object）。注意，<font color=red>adviced object 指的不是原来的类，而是织入 advice 后所产生的代理类</font>。

- AOP proxy：一个类被 AOP 织入 advice，就会产生一个==结果类==，它是融合了==原类==和==增强逻辑==的==代理类==。在 Spring AOP 中，一个 AOP 代理是一个 `JDK 动态代理对象`或 `CGLIB 代理对象`。
  - Spring AOP 默认使用标准的 ==JDK 动态代理==（dynamic proxy）技术来实现 AOP 代理。通过它，我们可以为任意的==接口==实现代理；
  - 如果需要为一个==类==实现代理，那么可以使用 ==CGLIB 代理==。当一个业务逻辑对象==没有实现接口==时，那么 Spring AOP 就默认使用 CGLIB 来作为 AOP 代理。即如果我们需要为一个方法织入 advice，但是这个方法不是一个接口所提供的方法，则此时 Spring AOP 会使用 CGLIB 来实现动态代理。
  - 鉴于此，<font color=red>Spring AOP 建议基于接口编程，对接口进行 AOP 而不是类</font>.。

- 织入：将 aspect 和其他对象连接起来，并创建 adviced object 的过程。根据不同的实现技术，AOP织入有三种方式（AspectJ 采用编译器织入和类装载器织入；Spring 采用动态代理织入）：
  - 编译器织入：这要求有特殊的 Java 编译器。
  - 类装载器织入：这需要有特殊的类装载器。
  - 动态代理织入：在运行期为目标类添加增强(Advice)生成子类的方式。

# @AspectJ 支持

**@AspectJ** 是一种使用 Java 注解来实现 AOP 的编码风格。@AspectJ 风格的 AOP 是 AspectJ Project 在 AspectJ 5 中引入的，并且 Spring 也支持@AspectJ 的 AOP 风格。

## 定义 aspect

当使用注解 **@Aspect** 标注一个 Bean 后，那么 Spring 框架会自动收集这些 Bean，并添加到 Spring AOP 中：

```java
@Component
@Aspect
public class MyTest {
}
```

注意，仅仅使用@Aspect 注解，并不能将一个 Java 对象转换为 Bean。我们还需要使用类似 @Component 之类的注解。如果一个 类被@Aspect 标注，则这个类就不能是其他 aspect 的 **advised object** 了，因为使用 @Aspect 后，这个类就会被排除在 auto-proxying 机制之外。

## 声明 pointcut

一个 pointcut 的声明由两部分组成：

- 一个==方法签名==，包括方法名和相关参数；
- 一个 ==pointcut 表达式==，用来指定哪些方法执行，是我们感兴趣的（即因此可以织入 advice）。

在@AspectJ 风格的 AOP 中，我们使用一个方法来描述 pointcut，即：

```java
// 切点表达式
@Pointcut("execution(* com.example.service.UserService.*(..))") 
private void dataAccessOperation() {}
```

<font color=red>这个方法必须无返回值！这个方法本身就是 pointcut signature，pointcut 表达式使用@Pointcut 注解指定</font>。

上面我们简单地定义了一个 pointcut，这个 pointcut 所描述的是：<font color=red>匹配所有在包 com.example.service.UserService 下的所有方法的执行</font>。

### 切点表达式

AspectJ5 的切点表达式由==标志符==（designator）和==操作参数==组成，如`execution(greetTo(..))`的切点表达式，execution 就是 标志符；而圆括号里的 greetTo(..) 就是操作参数。

> - [ ] 切点表达式的标识符待整理
>
>   原文链接：https://blog.csdn.net/qq_39368007/article/details/115470689

- execution：用于匹配方法执行连接点。 这是使用 Spring AOP 时使用的主要切点标识符。 可以匹配到==方法==级别 ，细粒度；
- within：只能匹配==类==这级，只能指定类，类下面的某个具体的方法无法指定，==粗粒度==；
- this：匹配实现了某个接口：`this(com.xyz.service.AccountService)`
- target：限制匹配到连接点（使用Spring AOP时方法的执行），其中目标对象（正在代理的应用程序对象）是给定类型的实例。
- args：限制与连接点的匹配（使用Spring AOP时方法的执行），其中变量是给定类型的实例。where the arguments are instances of the given types.
- @target：限制与连接点的匹配（使用Spring AOP时方法的执行），其中执行对象的类具有给定类型的注解。
- @args：限制匹配连接点（使用Spring AOP时方法的执行），其中传递的实际参数的运行时类型具有给定类型的注解。
- @within：限制与具有给定注解的类型中的连接点匹配（使用Spring AOP时在具有给定注解的类型中声明的方法的执行）。
- @annotation：限制匹配连接点（在Spring AOP中执行的方法具有给定的注解）。



# 参考资料

[彻底征服 Spring AOP 之 理论篇 - SegmentFault 思否](https://segmentfault.com/a/1190000007469968)

[彻底征服 Spring AOP 之 实战篇 - SegmentFault 思否](https://segmentfault.com/a/1190000007469982)
